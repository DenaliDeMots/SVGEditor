var _user$project$Utilities$applyOffset = F2(
	function (offset, position) {
		return {x: position.x + offset.x, y: position.y + offset.y};
	});
var _user$project$Utilities$getOffset = F2(
	function (position1, position2) {
		return {x: position2.x - position1.x, y: position2.y - position1.y};
	});
var _user$project$Utilities$distance = F2(
	function (start, end) {
		return _elm_lang$core$Basics$sqrt(
			Math.pow(
				_elm_lang$core$Basics$abs(start.x - end.x),
				2) + Math.pow(
				_elm_lang$core$Basics$abs(start.y - end.y),
				2));
	});
var _user$project$Utilities$intPositionToFloat = function (pos) {
	return {
		x: _elm_lang$core$Basics$toFloat(pos.x),
		y: _elm_lang$core$Basics$toFloat(pos.y)
	};
};
var _user$project$Utilities$lastInList = function (list) {
	lastInList:
	while (true) {
		var _p0 = list;
		if (_p0.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			if (_p0._1.ctor === '[]') {
				return {
					ctor: '::',
					_0: _p0._0,
					_1: {ctor: '[]'}
				};
			} else {
				var _v1 = _p0._1;
				list = _v1;
				continue lastInList;
			}
		}
	}
};
var _user$project$Utilities$maybeToList = function (a) {
	var _p1 = a;
	if (_p1.ctor === 'Nothing') {
		return {ctor: '[]'};
	} else {
		return {
			ctor: '::',
			_0: _p1._0,
			_1: {ctor: '[]'}
		};
	}
};
var _user$project$Utilities$until = F3(
	function (predicate, update, state) {
		until:
		while (true) {
			if (predicate(state)) {
				return state;
			} else {
				var _v3 = predicate,
					_v4 = update,
					_v5 = update(state);
				predicate = _v3;
				update = _v4;
				state = _v5;
				continue until;
			}
		}
	});

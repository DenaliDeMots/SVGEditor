module Main exposing (..)

--external modules

import Html
import Html.Events
import Svg exposing (Svg)
import Svg.Attributes as SvgA
import Svg.Events as SvgE
import Window
import Mouse
import Platform
import Json.Decode
import Color
import Color.Convert as CC
import Result


--internal modules

import Graphic exposing (Graphic)
import Action exposing (..)
import Tool exposing (Tool)
import Tool.Render
import Properties exposing (PropertyWidget, PropertyPalletState)
import Properties.Render
import Utilities
import Events
import Messages as Msg exposing (Msg)
import Messages.ClickTarget as ClickTarget exposing (ClickTarget)
import Messages.UpdatePropertyPallet as PPS
import Pallet exposing (Pallet)


main =
    Html.programWithFlags
        { init = init
        , update = update
        , view = view
        , subscriptions = subscriptions
        }



-----------------------------------------------------------------
--Model--


type alias Model =
    --System properties
    { windowSize : Window.Size
    , cursorPosition : CursorPosition
    , mouseDown : Bool
    , currentAction : Action
    , activeTool : Tool
    , toolPalletPosition : PalletPosition
    , propertyPalletPosition : PalletPosition
    , propertyPalletState : PropertyPalletState --Stroke/Fill color and stroke size info
    , graphics : List Graphic.Graphic -- The svg elements on the canvas
    , previewGraphic : Maybe Graphic -- The graphic currently being drawn.  If no graphic is being drawn this is Maybe.Nothing
    }



--Model--
---------------------------------------------------------------
--------------------------------------------------------------
--Initialization--


init : Window.Size -> ( Model, Cmd Msg )
init size =
    (initialModel
        |> setWindowSize size
        --Set the screen size based on the initial flags
        |> setPalletLocations size
     --place the pallets based on the initial screen size
    )
        ! []


initialModel =
    { windowSize = { width = 0, height = 0 }
    , cursorPosition = NotTracking
    , mouseDown = False
    , currentAction = None
    , activeTool = Tool.DrawRectangle
    , toolPalletPosition = { x = 0, y = 0, height = 0 }
    , propertyPalletPosition = { x = 0, y = 0, height = 0 }
    , propertyPalletState = initialPropertyPalletState
    , graphics = []
    , previewGraphic = Maybe.Nothing
    }


setWindowSize size model =
    { model
        | windowSize = size
    }


setPalletLocations size model =
    { model
        | toolPalletPosition =
            { x = toFloat size.width * 0.05 |> round
            , y = toFloat size.height * 0.1 |> round
            , height = 190
            }
        , propertyPalletPosition =
            { x = toFloat size.width * 0.95 - 85 |> round
            , y = toFloat size.height * 0.1 |> round
            , height = 170
            }
    }


initialPropertyPalletState =
    { fillColor = Color.green
    , strokeColor = Color.blue
    , strokeWidth = 4
    }



--Initialization--
----------------------------------------------------------------
----------------------------------------------------------------
--Update--


update : Msg -> Model -> ( Model, Cmd Msg )
update msg model =
    case msg of
        Msg.Resize size ->
            --Generated by the subscription to window size
            { model | windowSize = size } ! []

        Msg.UpdatePropertyPalletState stateMsg ->
            --I believe this is dead code originally implemented when I planned on using
            --a javascript colorpicker through a port
            let
                palletState =
                    model.propertyPalletState

                nextModel state =
                    { model | propertyPalletState = state }
            in
                case stateMsg of
                    PPS.UpdateFillColor color ->
                        let
                            nextPalletState =
                                { palletState | fillColor = color }
                        in
                            nextModel nextPalletState ! []

                    PPS.UpdateStrokeColor color ->
                        let
                            nextPalletState =
                                { palletState | fillColor = color }
                        in
                            nextModel nextPalletState ! []

                    PPS.StrokeWidth result ->
                        nextModel { palletState | strokeWidth = Result.withDefault palletState.strokeWidth result } ! []

        Msg.MouseDown clickTarget position ->
            --Update Logic is handled in the mouseDownEvent function.
            --The actual properties that are updated in the model can be seen here
            let
                ( modelUpdates, commands ) =
                    mouseDownEvent model clickTarget position
            in
                { model
                    | mouseDown = True
                    , cursorPosition = modelUpdates.cursorPosition
                    , currentAction = modelUpdates.currentAction
                    , activeTool = modelUpdates.activeTool
                    , propertyPalletState = modelUpdates.propertyPalletState
                }
                    ! commands

        Msg.MouseUp clickTarget position ->
            --Update Logic is handled in the mouseUpEvent function.
            --The actual properties that are updated in the model can be seen here
            let
                ( modelUpdates, commands ) =
                    mouseUpEvent model clickTarget position
            in
                { model
                    | mouseDown = False
                    , cursorPosition = modelUpdates.cursorPosition
                    , currentAction = modelUpdates.currentAction
                    , graphics = modelUpdates.graphics
                    , previewGraphic = modelUpdates.previewGraphic
                }
                    ! commands

        Msg.MouseMove position ->
            --Update Logic is handled in the mouseMoveEvent function.
            --The actual properties that are updated in the model can be seen here
            let
                ( modelUpdates, commands ) =
                    mouseMoveEvent model position
            in
                { model
                    | cursorPosition = modelUpdates.cursorPosition
                    , previewGraphic = modelUpdates.previewGraphic
                    , propertyPalletPosition = modelUpdates.propertyPalletPosition
                    , toolPalletPosition = modelUpdates.toolPalletPosition
                }
                    ! commands


mouseDownEvent : Model -> ClickTarget -> Position -> ( Model, List (Cmd Msg) )
mouseDownEvent model clickTarget position =
    --Updates the model based on which ClickTarget was recieved in the MouseDown message
    let
        --regardless of how the rest of the model gets updated, the mouseDown field should be set to True
        model2 =
            { model | mouseDown = True }
    in
        case clickTarget of
            ClickTarget.ToolPallet tool ->
                --Set the active drawing tool and cancel any other actions the user might be taking
                ( { model2
                    | currentAction = None
                    , activeTool = tool
                    , cursorPosition = NotTracking
                  }
                , []
                )

            ClickTarget.PalletHandle pallet ->
                --Set up for dragging either the Tool or Property pallet
                let
                    --Get the delta between the mouse position and the origin of the pallet
                    --This delta is used during moving to position the pallet based on the screen position of the mouse
                    offset =
                        Utilities.getOffset position
                            (case pallet of
                                Pallet.ToolPallet ->
                                    { x = model.toolPalletPosition.x, y = model.toolPalletPosition.y }

                                Pallet.PropertiesPallet ->
                                    { x = model.propertyPalletPosition.x, y = model.propertyPalletPosition.y }
                            )
                in
                    ( { model2
                        | currentAction = MovePallet pallet offset
                        , cursorPosition = Pos position
                      }
                    , []
                    )

            ClickTarget.PropertiesPallet widget ->
                --Set the fill/stroke color or the stroke width
                let
                    propPalletState =
                        model.propertyPalletState
                in
                    case widget of
                        Properties.FillColor pickerWidget ->
                            --clicking on the fill color box or on a part of the color picker while it is assosciated with the fill
                            let
                                newFillColor color =
                                    { propPalletState | fillColor = color }
                            in
                                case pickerWidget of
                                    --clicking on the color picker while selecting a fill color
                                    Properties.SaturationLightness posToColor ->
                                        --Clicking on the saturation/lightness box
                                        ( { model2
                                            | currentAction = SelectFillColor DraggingSatLight
                                            , propertyPalletState = newFillColor (posToColor position)
                                            , cursorPosition = Pos position
                                          }
                                        , []
                                        )

                                    Properties.Hue posToColor ->
                                        --Clicking on the hue bar
                                        ( { model2
                                            | currentAction = SelectFillColor DraggingHue
                                            , propertyPalletState = newFillColor (posToColor position)
                                            , cursorPosition = Pos position
                                          }
                                        , []
                                        )

                                    Properties.Background ->
                                        ( model2, [] )

                                    Properties.ColorBox ->
                                        --Toggle the color picker
                                        ( { model2
                                            | currentAction =
                                                case model2.currentAction of
                                                    SelectFillColor _ ->
                                                        None

                                                    _ ->
                                                        SelectFillColor NotDragging
                                          }
                                        , []
                                        )

                        Properties.StrokeColor pickerWidget ->
                            --clicking on the stroke color box or on a part of the color picker while it is assosciated with the stroke
                            let
                                newStrokeColor color =
                                    { propPalletState | strokeColor = color }
                            in
                                case pickerWidget of
                                    --clicking on the color picker while selecting a stroke color
                                    Properties.SaturationLightness posToColor ->
                                        --Clicking on the saturation/lightness box
                                        ( { model2
                                            | currentAction = SelectStrokeColor DraggingSatLight
                                            , propertyPalletState = newStrokeColor (posToColor position)
                                          }
                                        , []
                                        )

                                    Properties.Hue posToColor ->
                                        --Clicking on the hue bar
                                        ( { model2
                                            | currentAction = SelectStrokeColor DraggingHue
                                            , propertyPalletState = newStrokeColor (posToColor position)
                                          }
                                        , []
                                        )

                                    Properties.Background ->
                                        ( model2, [] )

                                    Properties.ColorBox ->
                                        --Toggle the color picker
                                        ( { model2
                                            | currentAction =
                                                case model2.currentAction of
                                                    SelectStrokeColor _ ->
                                                        None

                                                    _ ->
                                                        SelectStrokeColor NotDragging
                                          }
                                        , []
                                        )

                        Properties.StrokeWidth button ->
                            --clicking on either the increment or decrement buttons for stroke width
                            case button of
                                Properties.Increment ->
                                    let
                                        pPS =
                                            model2.propertyPalletState

                                        newPPS =
                                            { pPS | strokeWidth = pPS.strokeWidth + 1 }
                                    in
                                        ( { model2 | propertyPalletState = newPPS }, [] )

                                Properties.Decrement ->
                                    let
                                        pPS =
                                            model2.propertyPalletState

                                        newPPS =
                                            { pPS | strokeWidth = pPS.strokeWidth - 1 |> clamp 0 200 }
                                    in
                                        ( { model2 | propertyPalletState = newPPS }, [] )

            _ ->
                --This branch groups together the Screen and Graphic click targets.
                --If the user clicks on the screen or a drawn graphic update should be based on the drawing tool selected
                --The drawing tools set the current action to the corresponding draw action
                --The main drawing calculations are handled by the mouse move event
                case model.activeTool of
                    Tool.Select ->
                        --Select tool not implemented.  Intended for selecting drawn graphics for modification
                        case clickTarget of
                            ClickTarget.Screen ->
                                ( { model2
                                    | cursorPosition = NotTracking
                                    , currentAction = None
                                  }
                                , []
                                )

                            ClickTarget.Graphic graphic ->
                                Debug.crash "TODO - Selected a Graphic for editing"

                            _ ->
                                Debug.log "Evaluated unreachable branch" ( model2, [] )

                    Tool.DrawRectangle ->
                        ( { model2
                            | cursorPosition = Pos position
                            , currentAction = Draw (DrawRect position)
                          }
                        , []
                        )

                    Tool.DrawElipse ->
                        ( { model2
                            | cursorPosition = Pos position
                            , currentAction = Draw (DrawElipse position)
                          }
                        , []
                        )

                    Tool.DrawPolygon ->
                        let
                            --Get the starting point of the polygon and a list of the rest of the points
                            --If this is the first click, set the start point to the current mouse position.
                            ( startPoint, posList ) =
                                case model2.currentAction of
                                    Draw (DrawPolygon start list) ->
                                        ( start, list )

                                    _ ->
                                        ( Utilities.intPositionToFloat position, [] )
                        in
                            ( { model2
                                | cursorPosition = Pos position
                                , currentAction = Draw (DrawPolygon startPoint posList)
                                , previewGraphic = List.head <| createPolygon startPoint posList model2
                              }
                            , []
                            )


mouseUpEvent : Model -> ClickTarget -> Position -> ( Model, List (Cmd Msg) )
mouseUpEvent model clickTarget position =
    --Updates based on the action the user is taking when the mouse is released
    case model.currentAction of
        None ->
            ( { model
                | cursorPosition = NotTracking
              }
            , []
            )

        MovePallet pallet offset ->
            ( { model
                | currentAction = None
                , cursorPosition = NotTracking
              }
            , []
            )

        SelectFillColor pickerAction ->
            ( { model
                | cursorPosition = NotTracking
                , currentAction = SelectFillColor NotDragging
              }
            , []
            )

        SelectStrokeColor pickerAction ->
            ( { model
                | cursorPosition = NotTracking
                , currentAction = SelectStrokeColor NotDragging
              }
            , []
            )

        Draw drawAction ->
            --ending a draw action appends the preview graphic to the the list of drawn graphics
            case drawAction of
                DrawRect startPosition ->
                    ( { model
                        | currentAction = None
                        , cursorPosition = NotTracking
                        , graphics = model.graphics ++ Utilities.maybeToList model.previewGraphic
                        , previewGraphic = Maybe.Nothing
                      }
                    , []
                    )

                DrawElipse startPosition ->
                    ( { model
                        | currentAction = None
                        , cursorPosition = NotTracking
                        , graphics = model.graphics ++ Utilities.maybeToList model.previewGraphic
                        , previewGraphic = Maybe.Nothing
                      }
                    , []
                    )

                DrawPolygon startPoint posList ->
                    let
                        floatPosition =
                            Utilities.intPositionToFloat position

                        distanceFromStartPoint =
                            Utilities.distance startPoint floatPosition

                        numberOfPoints =
                            List.length posList

                        firstPoint =
                            floatPosition == startPoint && posList == []

                        --the polygon is complete when the mouse is released within the snapping distance of
                        --the start point (and there are at least 2 points)
                        completedPolygon =
                            numberOfPoints >= 2 && distanceFromStartPoint <= Graphic.polygonSnapDistance
                    in
                        if completedPolygon then
                            --If the polygon is completed, append the preview graphic to the list of graphics
                            ( { model
                                | currentAction = None
                                , cursorPosition = NotTracking
                                , graphics = model.graphics ++ createPolygon startPoint posList model
                                , previewGraphic = Maybe.Nothing
                              }
                            , []
                            )
                        else
                            --If the polygon is not completed, add the current click point to the list of polygon points
                            ( { model
                                | currentAction =
                                    Draw <|
                                        DrawPolygon startPoint
                                            --ignore creating a point if this is the upstroke of the initial click
                                            --the initial point is created on the downstroke
                                            (if firstPoint then
                                                posList
                                             else
                                                floatPosition :: posList
                                            )
                              }
                            , []
                            )


mouseMoveEvent model position =
    let
        model2 =
            { model
                | cursorPosition =
                    --only update the position if the mouse is supposed to be tracked
                    --mouse move events may be called by the subscription after the model
                    --has changed to Not Tracking
                    if model.cursorPosition == NotTracking then
                        NotTracking
                    else
                        Pos position
            }
    in
        case model2.currentAction of
            None ->
                ( model2, [] )

            MovePallet pallet offset ->
                let
                    newPosition =
                        Utilities.applyOffset offset position
                in
                    ( { model2
                        | currentAction = MovePallet Pallet.ToolPallet offset

                        --Set the either the tool or property pallet to the new position
                        , toolPalletPosition =
                            if pallet == Pallet.ToolPallet then
                                { x = newPosition.x, y = newPosition.y, height = model2.toolPalletPosition.height }
                            else
                                model2.toolPalletPosition
                        , propertyPalletPosition =
                            if pallet == Pallet.PropertiesPallet then
                                { x = newPosition.x, y = newPosition.y, height = model2.propertyPalletPosition.height }
                            else
                                model2.propertyPalletPosition
                      }
                    , []
                    )

            SelectFillColor pickerAction ->
                ( model2, [] )

            SelectStrokeColor pickerAction ->
                ( model2, [] )

            Draw drawAction ->
                ( updatePreviewGraphic drawAction position model2, [] )


updatePreviewGraphic drawAction currentPosition model =
    --This function and its helpers do the heavy lifting of drawing the graphics
    case drawAction of
        DrawRect startPosition ->
            { model
                | previewGraphic = List.head (createRectangle startPosition currentPosition model)
            }

        DrawElipse startPosition ->
            { model
                | previewGraphic = List.head (createElipse startPosition currentPosition model)
            }

        DrawPolygon startPoint posList ->
            let
                floatPosition =
                    Utilities.intPositionToFloat currentPosition

                snapToStart =
                    --if the cursor is close to the start point, don't use the current cursor position in the preview graphic
                    --so that the polygon gets drawn back to the start point instead of the current cursor position
                    Utilities.distance startPoint floatPosition <= Graphic.polygonSnapDistance && List.length posList >= 2
            in
                { model
                    | previewGraphic =
                        List.head <|
                            createPolygon startPoint
                                (if snapToStart then
                                    posList
                                 else
                                    floatPosition :: posList
                                )
                                model
                }



--Graphic Creation Functions--
--These functions create the graphics based on information in the model/messages
--They use the constructor functions from the Graphic module to produce the final data structures


createRectangle start end model =
    let
        recAttributes =
            { x = toFloat <| min start.x end.x -- Upper left x coordinate
            , y = toFloat <| min start.y end.y -- Upper left y coordinate
            , width = toFloat <| abs (start.x - end.x)
            , height = toFloat <| abs (start.y - end.y)
            , rx = 0 -- Corner x rounding radius
            , ry = 0 -- Corner y rounding radius
            }

        commonAttributes =
            { stroke = CC.colorToHex model.propertyPalletState.strokeColor
            , fill = CC.colorToHex model.propertyPalletState.fillColor
            , strokeWidth = toString model.propertyPalletState.strokeWidth
            }
    in
        if recAttributes.height == 0 || recAttributes.width == 0 then
            []
        else
            [ Graphic.createRectangle recAttributes commonAttributes ]


createElipse startPosition currentPosition model =
    --Start and current positions form the bounding box within which the elipse is drawn
    let
        xRadius =
            abs (startPosition.x - currentPosition.x) |> toFloat |> flip (/) 2

        yRadius =
            abs (startPosition.y - currentPosition.y) |> toFloat |> flip (/) 2

        elipseAttributes =
            { rx = xRadius
            , ry = yRadius
            , cx = toFloat (max startPosition.x currentPosition.x) - (xRadius) -- x center coordinate
            , cy = toFloat (max startPosition.y currentPosition.y) - (yRadius) -- y center coordinate
            }

        commonAttributes =
            { stroke = CC.colorToHex model.propertyPalletState.strokeColor
            , fill = CC.colorToHex model.propertyPalletState.fillColor
            , strokeWidth = toString model.propertyPalletState.strokeWidth
            }
    in
        if elipseAttributes.rx == 0 || elipseAttributes.ry == 0 then
            []
        else
            [ Graphic.createElipse elipseAttributes commonAttributes ]


createPolygon : { x : Float, y : Float } -> List { x : Float, y : Float } -> Model -> List Graphic
createPolygon startPoint polyList model =
    let
        commonAttributes =
            { stroke = CC.colorToHex model.propertyPalletState.strokeColor
            , fill = CC.colorToHex model.propertyPalletState.fillColor
            , strokeWidth = toString model.propertyPalletState.strokeWidth
            }
    in
        [ Graphic.createPolygon startPoint polyList commonAttributes ]



-------------------------------------------------------------------
-------------------------------------------------------------------
--Subscriptions--


subscriptions : Model -> Sub Msg
subscriptions model =
    [ Window.resizes (Msg.Resize)
    , Mouse.downs (Msg.MouseDown ClickTarget.Screen)
    , Mouse.ups (Msg.MouseUp ClickTarget.Screen)
    , trackPosition model.cursorPosition (Msg.MouseMove)
    ]
        |> Sub.batch


trackPosition cursor tagger =
    --This function determines whether to track the mouse cursorPosition property
    case cursor of
        NotTracking ->
            Sub.none

        _ ->
            Mouse.moves tagger



--Subscriptions--
--------------------------------------------------------------------
--------------------------------------------------------------------
--View--


view : Model -> Svg Msg
view model =
    let
        wHeight =
            model.windowSize.height

        wWidth =
            model.windowSize.width

        toolPalletPosition =
            model.toolPalletPosition

        propertyPalletPosition =
            model.propertyPalletPosition

        activeTool =
            model.activeTool

        propertyPalletState =
            model.propertyPalletState
    in
        Svg.svg
            [ SvgA.width <| toString wWidth
            , SvgA.height <| toString wHeight
            , SvgA.viewBox <| "0 0 " ++ toString wWidth ++ " " ++ toString wHeight
            , Events.mouseUpWithClickTarget <| ClickTarget.Screen
            , Events.mouseDownWithClickTarget <| ClickTarget.Screen
            ]
        <|
            --Create a list of Svg Msg data that will be rendered on screen
            --Begin with the Svg symbol elements
            symbols
                ++ (model.graphics
                        ++ Utilities.maybeToList model.previewGraphic
                        |> List.map
                            --Convert the list of Graphic data (preview + drawn graphics) to a list of Svg Msg data
                            (\graphic ->
                                Graphic.toSvg
                                    [ Events.mouseDownWithClickTarget <| ClickTarget.Graphic graphic
                                    , Events.mouseUpWithClickTarget <| ClickTarget.Graphic graphic
                                    ]
                                    graphic
                            )
                        |> flip (++)
                            --Append the Tool Pallet
                            [ Tool.Render.toolPallet
                                toolPalletPosition.x
                                toolPalletPosition.y
                                toolPalletPosition.height
                                activeTool
                            ]
                        |> flip (++)
                            --Append the Properties Pallet
                            [ Properties.Render.propertiesPallet
                                propertyPalletPosition.x
                                propertyPalletPosition.y
                                propertyPalletPosition.height
                                propertyPalletState
                                model.currentAction
                            ]
                   )



--SVG Symbol Elements


symbols =
    Tool.Render.symbols



----------------------------------------------------------------------
-----------------------------------------------------------------------
--Other Code--
--Data Types--


type CursorPosition
    = NotTracking
    | Pos Position


type alias PalletPosition =
    { x : Int, y : Int, height : Float }
